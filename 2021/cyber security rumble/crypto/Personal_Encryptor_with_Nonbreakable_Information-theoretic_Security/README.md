# Writeup for Personal Encryptor with None breakable Information-theoretic Security

| Category        | Author         | Points   | Solves |
| -------------   | -------------  | ------   | ------ |
| crypto          | rugo\|RedRocket| 200 + 20 | 46     |

In this challenge we exploit a broken keygen by analyzing the probability of the appearance of keybytes.

## Overview

We are presented a single python file that implements a keygen and an encryption routine. Upon execution, the user may request up to 1000 ciphertexts that are generated through encrypting the flag with a random key, generated by the keygen.

```python
import os
import string
import hashlib

from flag import FLAG

# Check that flag wasn't corrupted
assert hashlib.sha256(FLAG.encode()).hexdigest() == \
    "59f03b531db63fe65b7b8522badee65488d7a63fd97c3134766faf3d0fde427c", "Flag Corrupt!"


ALPHABET = string.ascii_letters + "{}_!$&-%?()"


def keygen(length):
    key = ""
    rnd_bytes = os.urandom(length)
    for i in range(length):
        pos = rnd_bytes[i] % len(ALPHABET)
        key += ALPHABET[pos]
    return key


def encrypt(key, msg):
    assert len(key) == len(msg), "For Information-theoretic security the key needs to be as long as the msg."

    ciphertext = ""

    for i in range(len(msg)):
        msg_c = msg[i]
        key_c = key[i]

        if msg_c not in ALPHABET:
            ValueError(f"Can't encrypt char: {msg_c}")

        msg_pos_c = ALPHABET.index(msg_c)
        key_pos_c = ALPHABET.index(key_c)

        new_pos = (msg_pos_c + key_pos_c) % len(ALPHABET)
        ciphertext += ALPHABET[new_pos]

    return ciphertext

print("Welcome to our `Personal Encryptor with Nonbreakable Information-theoretic Security` DEMO.")
print("With this PoC we show our unbreakable cipher.")
print("Request as many ciphertexts as you want. You won't be able to decrypt!")
print("To encrypt own messages please buy the full version.")

inpt = int(input("How many ciphertexts would you like>"))
if 0 < inpt <= 1000:
    for _ in range(inpt):
        key = keygen(len(FLAG))
        print(encrypt(key, FLAG))
else:
    print("Please be reasonable.")

print("Thanks for trying our demo version. Good bye.")

```

First notice that keys and plaintexts always consist of chars present in the ``ALPHABET``, so ``string.ascii_letters + "{}_!$&-%?()"``. So there are 63 different legal characters.

If we look at the encryption routine ``encrypt`` we can see that the algorithm simply iterates over the characters of both the key and the plaintext which are equally long and then adds the *indices* in the ``ALPHABET`` of these chars together
mod 63 to get the index of the next cipher char.

The ``keygen`` generates a random sequence of bytes and then uses them to derive a random char from the ``ALPHABET`` by calculating the mod 63 result.

## Analyzing the keygen

The unsigned integer representation of bytes range from 0 to 255. The length of the ``ALPHABET`` array is just 63. When calculating indices for new chars to be generated, some will be hit multiple times. For example, the index of 50, which is Y, will be hit by a random byte with value 50,113,176 and 239. Because ``255 != 0 mod 63``, __some entries will not only be hit by multiple byte values but more often than other indices__. 

To be more precise, exactly ``3 = 255 mod 63`` entries, so the first 4 chars = a,b,c and d will be hit one more time than the rest. This means, that the characters a,b,c,d will have a probability of 5/256 * 100 =
1.95 % (because there are 5 solutions for [0,1,2,3] = x mod 63) of being generated and all other chars will have the probability 4 / 256 * 100 = 1.56 % of being generated. lets quickly verify this:

```python
N = 1000000
charcount = {k:0 for k in ALPHABET}

rstring = keygen(N)

for c in rstring:
    charcount[c] += 1

for char,occ in sorted(charcount.items(), key=lambda p: p[1],reverse=True):
    print(f'{char} : {occ/N*100} %')
```

```
a : 1.9688 %
b : 1.9640000000000002 %
c : 1.9364 %
d : 1.9207999999999998 %
) : 1.599 %
R : 1.5792000000000002 %
W : 1.5786000000000002 %
C : 1.578 1 %
....
```
so we see that our assumptions were correct.

Now we can examine ``n``
different generated ciphertexts, a ciphertext corpus. When looking at each individual ciphertext char,
there exist 4 major subgroups in the ciphertext corpus. Namely the ciphertexts where the char was
encrypted with the index of ``a``, the index of ``b``, the index of ``c`` or the one of ``d``.
These groups are a bit larger than the rest and through that, detectable.

## Exploit strategy

We can abuse this behavior to recover the used key. We look at each individual char in
every ciphertext. Then for each index of ``a,b,c,d`` we decrypt each char with the according index.
We then look at the 4 largest groups in the resulting plaintext corpus. For each index of ``a,b,c,d``, one group will be made up
of the correct plaintext index. So after generating a list of the 4 most common plaintext indices
for each tried index of ``a,b,c,d``, we search for the plaintext char that appears in all 4 lists.
This will be the plaintext char.

```python
flag = ''
for flagindex in range(17):

    groups = []

    for probable_char in ['b','c','d','a']:

        proable_pos = ALPHABET.index(probable_char)

        counts = {x:0 for x in range(len(ALPHABET))}

        for ciphertext in ciphertexts:
    
            cipher_pos = ALPHABET.index(ciphertext[flagindex])

            guess = (cipher_pos - proable_pos) % len(ALPHABET)

            counts[guess] += 1

        most_common_subgroups = [x[0] for x in sorted(counts.items(), key=lambda x: x[1],reverse=True)[:4]]

        groups.append(most_common_subgroups)

    # search for char appearing in all 4 lists
    for index in groups[0]:
        found = True
        for group in groups[1:]:
            if not index in group:
                found = False
                break
        if found:
            flag += ALPHABET[index]
            break
    print(flag,end='\r')
print()
```

In the end, this gives us ``CSR{B!AS!SAB!TCH}``. I've toyed around with the number of ciphertexts and 25000 seems like a good value.